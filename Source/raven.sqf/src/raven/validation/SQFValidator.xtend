/*
 * generated by Xtext
 */
package raven.validation

import org.eclipse.xtext.validation.Check
import raven.sQF.SQFPackage
import raven.sQF.VarContent
import raven.sQF.DecContent
import raven.sQF.Declaration
import raven.sQF.BracketContent
import raven.sQF.Code
import raven.sQF.BooleanContent
import raven.sQF.Model
import raven.sQF.ForType
import raven.sQF.ForeachType
//import raven.sQF.AbstractDeclarationReference

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class SQFValidator extends AbstractSQFValidator {
	
	public static val UNARYOPERATOR_TO_NUMBERS_ONLY = "raven.sqf.UnaryOperatorToNumbersOnly"
	public static val UNARYOPERATOR_TO_ARRAY = "raven.sqf.UnaryOperatorToArray"
	public static val DECLARATIONS_ARE_SAME_TYPE = "raven.sqf.DeclarationsAreFromSameType"
	public static val ARRAYS_ONLY_ADDED_OR_SUBSTRACTED = "raven.sqf.ArraysOnlyAddedOrSubstracted"
	public static val STRINGS_ONLY_PLUS_OPERATOR = "raven.sqf.StringsOnlyPlusOperator"
	public static val SELFREFERENCE = "raven.sqf.SelfReference"
	public static val CYCLE_IN_HIERARCHY = "raven.sqf.CycleInHierarchy"
	public static val SELECT_ONLY_FOR_ARRAYS = "raven.sqf.SelectOnlyForArrays"
	public static val ARRAY_INDEX_OUT_OF_RANGE = "raven.sqf.ArrayIndexOutOfRange"
	public static val NEGATION_OPERATOR_ONLY_BOOLEAN = "raven.sqf.NegationOperatorOnlyBoolean"
	public static val COMPARISON_ONLY_WITH_SAME_TYPE = "raven.sqf.ComparisonOnlyWithSameType"
	public static val ONLY_BOOLEAN_ALLOWED = "raven.sqf.OnlyBooleanAllowed"
	public static val FOREACH_ONLY_ARRAY = "raven.sqf.ForEachOnlyArray"
	
	
	def static varContent(BracketContent brck) {
		val content = brck.decCon.singleContent
		return content
	}
	
	def static varContent(Declaration dec) {
		val content = dec.brCon.varContent
		return content
	}
	
	def static varContent(Code code) {
		val content = code.dec.varContent
		return content
	}
	
	def static decCon(Declaration dec) {
		val content = dec.brCon.decCon
		return content
	}
	
	def static decCon(Code code) {
		val content = code.dec.decCon
		return content
	}
	
	/**
	 * Checks that unary operator (+,-) are only applied to numbers or the + operator to an array
	 * This one only checks the first content in a declaration
	 */
	@Check
	def checkUnaryOperatorAssignedToNumbersOnlyFirst(DecContent dec) {
		if(dec.singleContent.unOP == null) {
			//proceed only if an unary operator is used
			return
		}
		
		var statement = dec.singleContent
		var parentStatement = getParent(statement)
		
		var type = getType(parentStatement)
		
		if(type == "array") {
			if (dec.singleContent.unOP == "-") {
				var errorMsg = "The unary operator '-' is not defined for type array"
				error(errorMsg, 
					SQFPackage.eINSTANCE.decContent_SingleContent,
					UNARYOPERATOR_TO_ARRAY)
			}
			return //the + operator is allowed for arrays
		}
				
		if(type != "number" && type != "undefined") {
			//if the content the unary operator is assigned to is not a number
			var errorMsg = "Unary operator can only be applied to numbers"
			error(errorMsg,
				SQFPackage.eINSTANCE.decContent_SingleContent,
				UNARYOPERATOR_TO_NUMBERS_ONLY
			)
		}		
	}
	
	/**
	 *  Checks that unary operator (+,-) are only applied to numbers
	 * This one checks all following content of a declaration
	 */
	@Check
	def checkUnaryOperatorAssignedToNumbersOnlyRest(DecContent dec) {
		if(dec.nextCon.isEmpty) {
			//proceed only if there are more contents
			return
		}
		
		for(i: 0..< dec.nextCon.length) {
			//go through all further contents
			var nextStatement = dec.nextCon.get(i) //select current
			
			if(nextStatement.unOP != null) {
				//execute only if a unary operator was used
				
				var type = getType(getParent(nextStatement))
								
				if(type != "number" && type != "undefined") {
					//if the content the unary operator is assigned to is not a number
					var errorMsg = "Unary operator can only be applied to numbers"
					error(errorMsg,
						SQFPackage.eINSTANCE.decContent_NextCon,
						i, UNARYOPERATOR_TO_NUMBERS_ONLY)
				}
			}
		}
		
	}
	
	/**
	 * Checks that all content within one declaration is from one type
	 */
	@Check
	def checkAllDeclarationsAreFromTheSameType(DecContent dec) {
		if(dec.nextCon.isEmpty) {
			//proceed only if there are multiple values
			return
		}
		//check that not multiple data types are used within one declaration
		var original = dec.singleContent //used to be able to use the "geThatReference"-Function
		
		val type = getType(original)
		if(type == "undefined") {
			//can not compare types
			return
		}
		
		for(i: 0..<dec.nextCon.length) {
			val nextContent = dec.nextCon.get(i)
			val nextType = getType(nextContent)
			
			if(type != nextType && nextType != "undefined") {
				val errorMsg = "Mismatch in type " + nextType + " -> expected " + type
				error(errorMsg,
					SQFPackage.eINSTANCE.decContent_NextCon,
					i, DECLARATIONS_ARE_SAME_TYPE)
			}
		}
		
/*		//if the first statement is a reference go back to it's real declaration
		if(original.reference != null) {
			original = getThatReference(original).singleContent
		}
		
		var embrType = ""
		if(original.embrCon != null) {
			var embr = original.embrCon.singleContent
			embrType = getType(embr)
		}
		
		//Number
		if(original.num != null || embrType == "number") {
			//check that following statements are numbers
			for(i: 0..<dec.nextCon.length) {
				var statement = dec.nextCon.get(i)
				
				//if statement is a reference look into it's declaration
				if(statement.reference != null) {
					statement = getThatReference(statement).singleContent
				}
				
				var type = getType(statement)
				
				if(type != "number" && type != "undefined") {
					var errorMsg = "Mismatch in type " + type + " -> expected number"
					error(errorMsg,
						SQFPackage.eINSTANCE.decContent_NextCon,
						i, DECLARATIONS_ARE_SAME_TYPE)
				}
			}
		}
		
		//string
		if(original.string != null || embrType == "string") {
			//check that following statements are strings
			for(i: 0..<dec.nextCon.length) {
				var checkStatement = dec.nextCon.get(i)
				
				//if statement is a reference look into it's declaration
				if(checkStatement.reference != null) {
					checkStatement = getThatReference(checkStatement).singleContent
				}
				
				var type = getType(checkStatement)
				
				if(type != "string" && type != "undefined") {
					var errorMsg = "Mismatch in type " + type + " -> expected string"
					error(errorMsg,
						SQFPackage.eINSTANCE.decContent_NextCon,
						i, DECLARATIONS_ARE_SAME_TYPE)
				}
			}
		}
		
		//arrays
		if(original.arrayContent != null) {
			//check that following statements are arrays
			for(i: 0..<dec.nextCon.length) {
				var checkStatement = dec.nextCon.get(i)
				
				//if statement is a reference look into it's declaration
				if(checkStatement.reference != null) {
					checkStatement = getThatReference(checkStatement).singleContent
				}
				
				var type = getType(checkStatement)
				if(type != "array" && type != "undefined") {
					var errorMsg = "Mismatch in type " + type + " -> expected array"
					error(errorMsg, 
						SQFPackage.eINSTANCE.decContent_NextCon,
						i, DECLARATIONS_ARE_SAME_TYPE)
				}
			}
		}*/
	}
	
	/**
	 * Checks that arrays are not multiplied or divided (adding or substracting is allowed)
	 */
	@Check
	def checkArraysAreOnlyAddedOrSubstracted(DecContent dec) {
		var original = dec.singleContent
		
		var type = getType(getParent(original))
		
		if(type != "array") {
			//proceed only if is array
			return
		}
		
		if(dec.op.isEmpty) {
			//proceed only if an operator was used
			return
		}
		
		for(i: 0..<dec.op.length) {
			var operator = dec.op.get(i)
			
			if(operator != "+" && operator != "-") {
				var errorMsg = "The operator '" + operator + "' is undefined for type array"
				error(errorMsg, 
					SQFPackage.eINSTANCE.decContent_Op,
					i, ARRAYS_ONLY_ADDED_OR_SUBSTRACTED)
			}
		}
	}
	
	/**
	 * Checks that strings can only make use of the + operator
	 */
	 @Check
	 def checkStringsOnlyUsePlusOperator(DecContent dec) {
	 	if(dec.nextCon.isEmpty) {
	 		//only proceed if there is at least one more content
	 		return
	 	}
	 	
	 	var type = getType(getParent(dec.singleContent))
	 	
	 	if(type != "string") {
	 		//only process strings
	 		return
	 	}
	 	
	 	for(i: 0..<dec.nextCon.length) {
	 		var operator = dec.op.get(i)
	 		
	 		if(operator != "+") {
	 			var errorMsg = "The operator '" + operator + "' is not defined for type string"
	 			error(errorMsg, 
	 				SQFPackage.eINSTANCE.decContent_Op,
	 				i, STRINGS_ONLY_PLUS_OPERATOR)
	 		}
	 	}
	 }
	
	/**
	 * Checks that all content within one bracket is from the same type
	 */
	@Check
	def checkAllDeclarationsAreFromTheSameTypeBrackets(VarContent con) {
		if(con.embrCon == null) {
			return
		}
		
		var bracketContent = con.embrCon.decCon
		
		bracketContent.checkAllDeclarationsAreFromTheSameType
	}
	
	/**
	 * Checks that "select" is only used with arrays
	 */
	 @Check
	 def checkSelectIsUsedOnArraysOnly(VarContent dec) {
	 	if(dec.sel == null) {
	 		//inly proceed when "select" was used
	 		return
	 	}
	 	
	 	val declaration = dec.reference
	 	val declarationType = getType(declaration)
	 	
	 	if(declarationType != "array") {
	 		val errorMsg = "The command 'select' is not applicable for type " + declarationType
	 		error(errorMsg,
	 			SQFPackage.eINSTANCE.varContent_Sel,
	 			SELECT_ONLY_FOR_ARRAYS)
	 			
	 	}
	 }
	 
	 /**
	  * Checks that negation operators("!" and "not") are only applied to boolean expressions
	  */
	  
	  @Check
	  def checkNegationOperatorOnlyUsedForBooleanExpressions(DecContent dec) {
	  	if(dec.neg == null) {
	  		//proceed only if a negation operator was used
	  		return
	  	}
	  	
	  	val operator = dec.neg
	  	val current = dec.singleContent
	  	val brCon = dec.eContainer as BracketContent
	  	val type = getType(brCon)
	  	
	  	if(type != "boolean") {
	  		val errorMsg = "The operator '" + operator + "' is not defined for type " + type
	  		error(errorMsg,
	  			SQFPackage.eINSTANCE.decContent_Neg,
	  			NEGATION_OPERATOR_ONLY_BOOLEAN)
	  			return
	  	}
	  	
/*	  	if(getType(current) != "boolean") {
	  		var String errorMsg
	  		if(current.embrCon != null) {
	  			errorMsg = "Operator '" + operator + "' is not applicable for type " + type + " -> use brackets to clarify comparison"
	  		}else {
	  			errorMsg = "The operator '" + operator + "' is not defined for type " + type
	  		}
	  		
	  		error(errorMsg,
	  			SQFPackage.eINSTANCE.decContent_Neg,
	  			NEGATION_OPERATOR_ONLY_BOOLEAN)
	  	}*/
	  }
	
	/**
	 * Checks that array index is not out of range
	 */
/*	 @Check
	 def checkArrayIndexNotOutOfRange(VarContent dec) {
	 	if(getType(dec) != "array") {
	 		//proceed only if it's an array
	 		return
	 	}
	 	
	 	if(dec.sel == null) {
	 		//proceed only if "select" was used
	 		return
	 	}
	 	
	 	val declaration = dec.reference
	 	val declarationtype = getType(declaration.decCon.singleContent)
	 	
	 	if(declarationtype != "array") {
	 		//proceed only if an array was used
	 		return
	 	}
	 	
	 	var elementsQuantity = getArrayElementCount(declaration)
	 	
	 	var int index = Integer.parseInt(dec.index)
	 	
	 	if(index >= elementsQuantity) {
	 		val errorMsg = "Index out of range (addressed " + index.toString + " but last index is " + (elementsQuantity- 1).toString + ")"
	 		error(errorMsg,
	 			SQFPackage.eINSTANCE.varContent_Index,
	 			ARRAY_INDEX_OUT_OF_RANGE)
	 	}
	 	
	 	
	 }TODO*/
	
	/**
	 * Checks that a comparison is only done via "==" if 2 values of the same type is used
	 */
	@Check
	def checkComparisonDoneOnlyBetweenSameTypes(BracketContent brCon) {
		if(brCon.comp.isEmpty || brCon.content.isEmpty) {
			//proceed only if a comparator was used
			return
		}
		
		for(i: 0..<brCon.comp.length) {
			 var comparator = brCon.comp.get(i)
			 var VarContent firstContent
			 
			 if(i == 0) {
			 	firstContent = brCon.decCon.singleContent
			 }else {
			 	firstContent = brCon.content.get(i-1).singleContent
			 }
			 
			 var nextContent = brCon.content.get(i).singleContent
			 
			 var firstType = getType(firstContent)
			 var nextType = getType(nextContent)
			 
			 if(!firstType.equals(nextType) && firstType != "undefined" && nextType != "undefined" && comparator != "isEqualTo") {
			 	val errorMsg = "Can't compare type " + firstType + " and " + nextType + " with comparator '" + comparator + "'"
			 	error(errorMsg,
			 		SQFPackage.eINSTANCE.bracketContent_Comp,
			 		i, COMPARISON_ONLY_WITH_SAME_TYPE)
			 		//TODO: add QuickFix to change comparator to "isEqualTo"
			 }
		 }
		 
		
	}
	
	
	//General
	/**
	 * Check that a variable is not just a reference to itself
	 */
/*	 @Check
	 def checkDeclarationIsNotReferenceToItself(Declaration dec) {
	 	if(dec.decCon.singleContent.reference == null && !dec.decCon.nextCon.isEmpty) {
	 		//only proceed if it is a reference
	 		return
	 	}
	 	
	 	var name = dec.name
	 	
	 	if(dec.decCon.singleContent.reference.name == name) {
	 		//only if the declaration is a self-reference without further actions
	 		var warningMsg = "The declaration '" + name + "' is a reference to itself"
	 		warning(warningMsg, 
	 			SQFPackage.eINSTANCE.bracketContent_DecCon,
	 			SELFREFERENCE)
	 	}
	 }TODO*/
	 
	 
	 
	 /**
	  * Checks that there is no cycle in hierarchy
	  */
	  @Check
	  def checkNoCycleInHierarchy(Declaration dec) {
	  	if(dec.varContent.reference == null) {
	  		//proceed only if there is a reference
	  		return
	  	}
	  	
	  	if(dec.name == dec.varContent.reference.name) {
	  		//reference to itsself is another Method
	  		return
	  	}
	  	
	  	var content = dec.varContent
	  	
	  	var names = newArrayList
	  	
	  	while(content.reference != null && !names.contains(getParentName(content))) {
	  		names.add(getParentName(content))
	  		content = content.reference.varContent
	  		
	  		if(names.contains(getParentName(content))) {
	  			val errorMsg = "Cycle in hierarchy!"
	  			error(errorMsg,
	  				SQFPackage.eINSTANCE.declaration_BrCon,
	  				CYCLE_IN_HIERARCHY)
	  				
	  				return
	  		}
	  	}
	  }
	  
	  /** 
	   * Checks that the rule booleanContent contains only boolean
	   */
	  @Check
	  def checkBoolContentIsAlwaysBoolean(BooleanContent bool) {
	  	val type = getType(bool.boolCon)
	  	
	  	if(type != "boolean" && type != "undefined") {
	  		val errorMsg = "Mismatch in type " + type + " -> expected boolean"
	  		error(errorMsg,
	  			SQFPackage.eINSTANCE.booleanContent_BoolCon,
	  			ONLY_BOOLEAN_ALLOWED)
	  	}
	  }
	  
	  /**
	   * Checks that a foreach only refers to an array
	   */
	   @Check
	   def checkForEachOnlyUsesArray(ForeachType forEach) {
	   	if(forEach.array == null) {
	   		//only proceed if a reference was used
	   		return
	   	}
	   	
	   	val type = getType(forEach.array)
	   		if(type != "array" && type != "undefined") {
	   			val errorMsg = "ForEach can only process arrays"
	   			error(errorMsg,
	   				SQFPackage.eINSTANCE.foreachType_Array,
	   				FOREACH_ONLY_ARRAY)
	   		}
	   }
	
	
	//Misc
	/**
	 * Tracks a reference back to it's delaration and returns the declaration content
	 */
	def static getThatReference(VarContent statement) {
		var ref = statement.reference
		var stat = statement
		var names = newArrayList
		var variable = ref.decCon
		
		while(ref != null && !names.contains(ref.name)) {
			names.add(ref.name)
			stat = ref.decCon.singleContent //save the current contents if ref now is null
			variable = ref.decCon
			ref = stat.reference
		}
		
		return variable
	}
	
	/**
	 * finds out the type of the declaration and returns it ("number","string","array","undefined"; if nothing has matched:"Couldn'tResolveToType")
	 */
	def static getType(VarContent con){
		var content = con
		var names = newArrayList
		var proceed = true
		
		while((content.reference != null || content.embrCon != null) && proceed) {
			if(content.reference != null){
				val name = getReferenceName(content)
				
					if(names.contains(name)) {
						proceed = false //Then it's a reference to itself
					}else {
						names.add(name)
					}
					
				content = getThatReference(content).singleContent
			}else {
				if(content.embrCon != null) {
					content = (getBracketContent(content) as BracketContent).decCon.singleContent
				}else {
					println("ERROR: COULDN'T RESOLVE REFERENCE/BRACKETS")
				}
			}
		}
		
		if(content.bool != null) {
			return "boolean"
		}
		
		if(content.num != null) {
			return "number"
		}
		
		if(content.string != null) {
			return "string"
		}
		
		if(content.arrayContent != null || (content.param != null && content.index == null)) {
			return "array"
		}
		
		if(content.param != null && content.index != null) {
			return "undefined" //parameter can be any type
		}
		
		if(content.forEachVar != null) {
			return "undefined"
		}
		
		return "Couldn'tResolveToType"
	}
	
	
	def static getType(Declaration dec){
		val type = getType(dec.brCon)
		return type
	}
	
	def static getType(BracketContent brCon) {
		var brContent = brCon
		var names = newArrayList
		var BracketContent boolChecker
		var proceed = true
		var content = brContent.decCon.singleContent
		
		var isBool = !brContent.comp.isEmpty
		
		while((content.reference != null || content.embrCon != null) && proceed) {
			if(content.reference != null){
				val name = getReferenceName(content)
				
					if(names.contains(name)) {
						proceed = false //Then it's a reference to itself
					}else {
						names.add(name)
					}
				
				if(!isBool) {
					isBool = !brContent.comp.isEmpty
					
					if(!isBool && boolChecker != null) {
						isBool = !boolChecker.comp.isEmpty
					}
				}
				
				content = getThatReference(content).singleContent
				brContent = content.eContainer.eContainer as BracketContent
			}else {
				if(content.embrCon != null) {
					brContent = (getBracketContent(content) as BracketContent)
					content = brContent.decCon.singleContent
				}else {
					println("ERROR: COULDN'T RESOLVE REFERENCE/BRACKETS")
				}
			}
		}
		
		if(!isBool) {
			isBool = !brContent.comp.isEmpty
			
			if(!isBool && boolChecker != null) {
				isBool = !boolChecker.comp.isEmpty
			}
		}
		
		if(isBool || content.bool != null) {
			return "boolean"
		}
		
		if(content.num != null) {
			return "number"
		}
		
		if(content.string != null) {
			return "string"
		}
		
		if(content.execute != null) {
			return "methodCall"
		}
		
		if(content.arrayContent != null || (content.param != null && content.index == null)) {
			return "array"
		}
		
		if(content.param != null && content.index != null) {
			return "undefined" //parameter can be any type
		}
		
		if(content.forEachVar != null) {
			return "undefined"
		}
		
		return "Couldn'tResolveToType"
	}
	
/*	def getType(AbstractDeclarationReference ref) {
		if(ref.object != null) {
			return "object"
		}
		
		if(ref.forEachVariable != null) {
			return "undefined"
		}
		
		if(ref.loopDeclaration != null) {
			return "undefined"
		}
		
		if(ref.declaration != null) {
			val dec = ref.declaration.brCon
			val type = getType(dec)
			return type
		}
		
		return "Couldn'tResolveType"
	}*/
	
	/**
	 * gets the declaration content between brackets and returns it
	 */
	def static getBracketContent(VarContent con) {
		if(con.embrCon == null) {
			return con.eContainer.eContainer as BracketContent //if there are no brackets return original
		}
		
		var content = con.embrCon
		
		return content
	}
	
	/**
	 * finds out the name of the declaration the Content belongs to
	 */
	def static getParentName(VarContent con) {
		val parent = getParent(con)
		val name = parent.name
		
		return name
	}
	
	/**
	 * returns the parent Rule
	 */
	 def static getParent(VarContent con) {
	 	val dummy = con.reference as Declaration
	 	var parentSuper = con.eContainer.eContainer
	 	var Declaration parent
		 
		while(parentSuper != null && !(parentSuper instanceof Declaration)) {
			parentSuper = parentSuper.eContainer
		}
		
		if(parentSuper == null) {
			println("ERROR: Couldn't find parent to element " + con.toString)
			return null
		}
	 	
	 	if(parentSuper instanceof Declaration) {
		 	parent = (parentSuper as Declaration)
		}
	 	
	 	return parent
	 }
	 
	 /**
	  * Gets the name of the reference Declaration
	  */
	  
	  def static getReferenceName(VarContent con) {
	  	if(con.reference == null) {
	  		return null
	  	}
	  	
	  	val name = (con.reference as Declaration).name
	  	
	  	return name
	  }
	
	/**
	 * Finds out how many elements an array has
	 */
/*	 def static int getArrayElementCount(Declaration dec) {
	 	var elements = 0
	 	if(getType(dec.decCon.singleContent) == "array") {
	 		var stat = dec
	 		var names = newArrayList
	 		
	 		while(stat.decCon.singleContent.reference != null && !names.contains(stat.name)) {
	 			var nextArrayList = stat.decCon.nextCon
	 			
	 			for(i: 0..< nextArrayList.length) {
	 				var nextArray = nextArrayList.get(i).reference
	 				
	 				elements = getArrayElementCount(nextArray)
	 			}
	 			stat = stat.decCon.singleContent.reference
	 		}
	 		
	 		var array = stat.decCon.singleContent.arrayContent
	 		
	 		if(array.nextContent.isEmpty){
	 			elements += 1
	 		}else{
	 			elements = array.nextContent.length + 1
	 		}	
	 	}
	 	
	 	return elements
	 } TODO*/
}

