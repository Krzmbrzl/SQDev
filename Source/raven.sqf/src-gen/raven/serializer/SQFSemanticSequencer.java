/*
 * generated by Xtext
 */
package raven.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import raven.sQF.ANYTHING;
import raven.sQF.ArrayLiteral;
import raven.sQF.BooleanContent;
import raven.sQF.BracketContent;
import raven.sQF.Code;
import raven.sQF.ControlStructure;
import raven.sQF.DecContent;
import raven.sQF.Declaration;
import raven.sQF.ForType;
import raven.sQF.ForeachType;
import raven.sQF.Method;
import raven.sQF.MethodName;
import raven.sQF.Model;
import raven.sQF.SQFPackage;
import raven.sQF.SwitchType;
import raven.sQF.VarContent;
import raven.sQF.WhileType;
import raven.sQF.forVarDeclaration;
import raven.sQF.ifType;
import raven.services.SQFGrammarAccess;

@SuppressWarnings("all")
public class SQFSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SQFGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == SQFPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case SQFPackage.ANYTHING:
				sequence_ANYTHING(context, (ANYTHING) semanticObject); 
				return; 
			case SQFPackage.ARRAY_LITERAL:
				sequence_ArrayLiteral(context, (ArrayLiteral) semanticObject); 
				return; 
			case SQFPackage.BOOLEAN:
				sequence_Boolean(context, (raven.sQF.Boolean) semanticObject); 
				return; 
			case SQFPackage.BOOLEAN_CONTENT:
				sequence_BooleanContent(context, (BooleanContent) semanticObject); 
				return; 
			case SQFPackage.BRACKET_CONTENT:
				sequence_BracketContent(context, (BracketContent) semanticObject); 
				return; 
			case SQFPackage.CODE:
				sequence_Code(context, (Code) semanticObject); 
				return; 
			case SQFPackage.CONTROL_STRUCTURE:
				sequence_ControlStructure(context, (ControlStructure) semanticObject); 
				return; 
			case SQFPackage.DEC_CONTENT:
				sequence_DecContent(context, (DecContent) semanticObject); 
				return; 
			case SQFPackage.DECLARATION:
				if(context == grammarAccess.getAbstractDeclarationReferenceRule()) {
					sequence_AbstractDeclarationReference(context, (Declaration) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getDeclarationRule()) {
					sequence_Declaration(context, (Declaration) semanticObject); 
					return; 
				}
				else break;
			case SQFPackage.FOR_TYPE:
				sequence_ForType(context, (ForType) semanticObject); 
				return; 
			case SQFPackage.FOREACH_TYPE:
				sequence_ForeachType(context, (ForeachType) semanticObject); 
				return; 
			case SQFPackage.METHOD:
				sequence_Method(context, (Method) semanticObject); 
				return; 
			case SQFPackage.METHOD_NAME:
				sequence_MethodName(context, (MethodName) semanticObject); 
				return; 
			case SQFPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case SQFPackage.OBJECT:
				sequence_Object(context, (raven.sQF.Object) semanticObject); 
				return; 
			case SQFPackage.SWITCH_TYPE:
				sequence_SwitchType(context, (SwitchType) semanticObject); 
				return; 
			case SQFPackage.VAR_CONTENT:
				sequence_VarContent(context, (VarContent) semanticObject); 
				return; 
			case SQFPackage.WHILE_TYPE:
				sequence_WhileType(context, (WhileType) semanticObject); 
				return; 
			case SQFPackage.FOR_VAR_DECLARATION:
				if(context == grammarAccess.getForTypeRule()) {
					sequence_ForType_forVarDeclaration(context, (forVarDeclaration) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getForVarDeclarationRule()) {
					sequence_forVarDeclaration(context, (forVarDeclaration) semanticObject); 
					return; 
				}
				else break;
			case SQFPackage.IF_TYPE:
				sequence_ifType(context, (ifType) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (bool=Boolean | num=NUMBER | string=STRING | reference=[Declaration|ID])
	 */
	protected void sequence_ANYTHING(EObject context, ANYTHING semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (declaration=Declaration | loopDeclaration=forVarDeclaration)
	 */
	protected void sequence_AbstractDeclarationReference(EObject context, Declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (con='[' (content=VarContent nextContent+=VarContent*)?)
	 */
	protected void sequence_ArrayLiteral(EObject context, ArrayLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     boolCon=BracketContent
	 */
	protected void sequence_BooleanContent(EObject context, BooleanContent semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SQFPackage.Literals.BOOLEAN_CONTENT__BOOL_CON) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SQFPackage.Literals.BOOLEAN_CONTENT__BOOL_CON));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBooleanContentAccess().getBoolConBracketContentParserRuleCall_0(), semanticObject.getBoolCon());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (bool='true' | bool='false' | command=BoolCommand)
	 */
	protected void sequence_Boolean(EObject context, raven.sQF.Boolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (decCon=DecContent (comp+=COMPARATOR content+=DecContent)*)
	 */
	protected void sequence_BracketContent(EObject context, BracketContent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (dec=Declaration | control=ControlStructure | method=Method)
	 */
	protected void sequence_Code(EObject context, Code semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (ifStat=ifType | whileStat=WhileType | forStat=ForType | forEachStat=ForeachType | switchStat=SwitchType)
	 */
	protected void sequence_ControlStructure(EObject context, ControlStructure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((neg='!' | neg='not')? singleContent=VarContent (op+=OPERATOR nextCon+=VarContent)*)
	 */
	protected void sequence_DecContent(EObject context, DecContent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID brCon=BracketContent)
	 */
	protected void sequence_Declaration(EObject context, Declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (begin=Declaration condition=BooleanContent end=Declaration loopCode+=Code*)
	 */
	protected void sequence_ForType(EObject context, ForType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=STRING from=NUMBER to=NUMBER step=NUMBER? loopCode+=Code*)
	 */
	protected void sequence_ForType_forVarDeclaration(EObject context, forVarDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (code+=Code* (array=[Declaration|ID] | arrayLiteral=ArrayLiteral))
	 */
	protected void sequence_ForeachType(EObject context, ForeachType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ref=[Declaration|ID]
	 */
	protected void sequence_MethodName(EObject context, MethodName semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SQFPackage.Literals.METHOD_NAME__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SQFPackage.Literals.METHOD_NAME__REF));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMethodNameAccess().getRefDeclarationIDTerminalRuleCall_0_1(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (params=ArrayLiteral execute='spawn' methodName=MethodName)
	 */
	protected void sequence_Method(EObject context, Method semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SQFPackage.Literals.METHOD__PARAMS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SQFPackage.Literals.METHOD__PARAMS));
			if(transientValues.isValueTransient(semanticObject, SQFPackage.Literals.METHOD__EXECUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SQFPackage.Literals.METHOD__EXECUTE));
			if(transientValues.isValueTransient(semanticObject, SQFPackage.Literals.METHOD__METHOD_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SQFPackage.Literals.METHOD__METHOD_NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMethodAccess().getParamsArrayLiteralParserRuleCall_0_0(), semanticObject.getParams());
		feeder.accept(grammarAccess.getMethodAccess().getExecuteSpawnKeyword_1_0(), semanticObject.getExecute());
		feeder.accept(grammarAccess.getMethodAccess().getMethodNameMethodNameParserRuleCall_2_0(), semanticObject.getMethodName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     elements+=Code*
	 */
	protected void sequence_Model(EObject context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Object(EObject context, raven.sQF.Object semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SQFPackage.Literals.OBJECT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SQFPackage.Literals.OBJECT__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getObjectAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (var=[Declaration|ID] (value+=ANYTHING caseCode+=Code*)* defaultCode+=Code*)
	 */
	protected void sequence_SwitchType(EObject context, SwitchType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         ((unOP='+' | unOP='-')? num=NUMBER) | 
	 *         string=STRING | 
	 *         ((unOP='+' | unOP='-')? (reference=[Declaration|ID] | forEachVar='_x') (sel='select' index=NUMBER)?) | 
	 *         (arrayContent=ArrayLiteral (execute='call' methodName=MethodName)?) | 
	 *         ((unOP='+' | unOP='-')? embraced='(' embrCon=BracketContent) | 
	 *         bool=Boolean | 
	 *         (param='_this' index=NUMBER?)
	 *     )
	 */
	protected void sequence_VarContent(EObject context, VarContent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (condition=BooleanContent loopCode+=Code*)
	 */
	protected void sequence_WhileType(EObject context, WhileType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=STRING
	 */
	protected void sequence_forVarDeclaration(EObject context, forVarDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (condition=BooleanContent ((thenCode+=Code* elseCode+=Code*) | (thenCode+=Code* elseCode+=Code*) | exitCode+=Code*))
	 */
	protected void sequence_ifType(EObject context, ifType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
