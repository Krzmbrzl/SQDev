/**
 * generated by Xtext
 */
package raven.validation;

import com.google.common.base.Objects;
import java.util.ArrayList;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.ExclusiveRange;
import org.eclipse.xtext.xbase.lib.InputOutput;
import raven.sQF.ArrayLiteral;
import raven.sQF.BooleanContent;
import raven.sQF.BracketContent;
import raven.sQF.Code;
import raven.sQF.DecContent;
import raven.sQF.Declaration;
import raven.sQF.ForeachType;
import raven.sQF.SQFPackage;
import raven.sQF.VarContent;
import raven.validation.AbstractSQFValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class SQFValidator extends AbstractSQFValidator {
  public final static String UNARYOPERATOR_TO_NUMBERS_ONLY = "raven.sqf.UnaryOperatorToNumbersOnly";
  
  public final static String UNARYOPERATOR_TO_ARRAY = "raven.sqf.UnaryOperatorToArray";
  
  public final static String DECLARATIONS_ARE_SAME_TYPE = "raven.sqf.DeclarationsAreFromSameType";
  
  public final static String ARRAYS_ONLY_ADDED_OR_SUBSTRACTED = "raven.sqf.ArraysOnlyAddedOrSubstracted";
  
  public final static String STRINGS_ONLY_PLUS_OPERATOR = "raven.sqf.StringsOnlyPlusOperator";
  
  public final static String SELFREFERENCE = "raven.sqf.SelfReference";
  
  public final static String CYCLE_IN_HIERARCHY = "raven.sqf.CycleInHierarchy";
  
  public final static String SELECT_ONLY_FOR_ARRAYS = "raven.sqf.SelectOnlyForArrays";
  
  public final static String ARRAY_INDEX_OUT_OF_RANGE = "raven.sqf.ArrayIndexOutOfRange";
  
  public final static String NEGATION_OPERATOR_ONLY_BOOLEAN = "raven.sqf.NegationOperatorOnlyBoolean";
  
  public final static String COMPARISON_ONLY_WITH_SAME_TYPE = "raven.sqf.ComparisonOnlyWithSameType";
  
  public final static String ONLY_BOOLEAN_ALLOWED = "raven.sqf.OnlyBooleanAllowed";
  
  public final static String FOREACH_ONLY_ARRAY = "raven.sqf.ForEachOnlyArray";
  
  public static VarContent varContent(final BracketContent brck) {
    DecContent _decCon = brck.getDecCon();
    final VarContent content = _decCon.getSingleContent();
    return content;
  }
  
  public static VarContent varContent(final Declaration dec) {
    BracketContent _brCon = dec.getBrCon();
    final VarContent content = SQFValidator.varContent(_brCon);
    return content;
  }
  
  public static VarContent varContent(final Code code) {
    Declaration _dec = code.getDec();
    final VarContent content = SQFValidator.varContent(_dec);
    return content;
  }
  
  public static DecContent decCon(final Declaration dec) {
    BracketContent _brCon = dec.getBrCon();
    final DecContent content = _brCon.getDecCon();
    return content;
  }
  
  public static DecContent decCon(final Code code) {
    Declaration _dec = code.getDec();
    final DecContent content = SQFValidator.decCon(_dec);
    return content;
  }
  
  /**
   * Checks that unary operator (+,-) are only applied to numbers or the + operator to an array
   * This one only checks the first content in a declaration
   */
  @Check
  public void checkUnaryOperatorAssignedToNumbersOnlyFirst(final DecContent dec) {
    VarContent _singleContent = dec.getSingleContent();
    String _unOP = _singleContent.getUnOP();
    boolean _equals = Objects.equal(_unOP, null);
    if (_equals) {
      return;
    }
    VarContent statement = dec.getSingleContent();
    Declaration parentStatement = SQFValidator.getParent(statement);
    String type = SQFValidator.getType(parentStatement);
    boolean _equals_1 = Objects.equal(type, "array");
    if (_equals_1) {
      VarContent _singleContent_1 = dec.getSingleContent();
      String _unOP_1 = _singleContent_1.getUnOP();
      boolean _equals_2 = Objects.equal(_unOP_1, "-");
      if (_equals_2) {
        String errorMsg = "The unary operator \'-\' is not defined for type array";
        EReference _decContent_SingleContent = SQFPackage.eINSTANCE.getDecContent_SingleContent();
        this.error(errorMsg, _decContent_SingleContent, 
          SQFValidator.UNARYOPERATOR_TO_ARRAY);
      }
      return;
    }
    boolean _and = false;
    boolean _notEquals = (!Objects.equal(type, "number"));
    if (!_notEquals) {
      _and = false;
    } else {
      boolean _notEquals_1 = (!Objects.equal(type, "undefined"));
      _and = _notEquals_1;
    }
    if (_and) {
      String errorMsg_1 = "Unary operator can only be applied to numbers";
      EReference _decContent_SingleContent_1 = SQFPackage.eINSTANCE.getDecContent_SingleContent();
      this.error(errorMsg_1, _decContent_SingleContent_1, 
        SQFValidator.UNARYOPERATOR_TO_NUMBERS_ONLY);
    }
  }
  
  /**
   * Checks that unary operator (+,-) are only applied to numbers
   * This one checks all following content of a declaration
   */
  @Check
  public void checkUnaryOperatorAssignedToNumbersOnlyRest(final DecContent dec) {
    EList<VarContent> _nextCon = dec.getNextCon();
    boolean _isEmpty = _nextCon.isEmpty();
    if (_isEmpty) {
      return;
    }
    EList<VarContent> _nextCon_1 = dec.getNextCon();
    int _length = ((Object[])Conversions.unwrapArray(_nextCon_1, Object.class)).length;
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _length, true);
    for (final Integer i : _doubleDotLessThan) {
      {
        EList<VarContent> _nextCon_2 = dec.getNextCon();
        VarContent nextStatement = _nextCon_2.get((i).intValue());
        String _unOP = nextStatement.getUnOP();
        boolean _notEquals = (!Objects.equal(_unOP, null));
        if (_notEquals) {
          Declaration _parent = SQFValidator.getParent(nextStatement);
          String type = SQFValidator.getType(_parent);
          boolean _and = false;
          boolean _notEquals_1 = (!Objects.equal(type, "number"));
          if (!_notEquals_1) {
            _and = false;
          } else {
            boolean _notEquals_2 = (!Objects.equal(type, "undefined"));
            _and = _notEquals_2;
          }
          if (_and) {
            String errorMsg = "Unary operator can only be applied to numbers";
            EReference _decContent_NextCon = SQFPackage.eINSTANCE.getDecContent_NextCon();
            this.error(errorMsg, _decContent_NextCon, (i).intValue(), SQFValidator.UNARYOPERATOR_TO_NUMBERS_ONLY);
          }
        }
      }
    }
  }
  
  /**
   * Checks that all content within one declaration is from one type
   */
  @Check
  public void checkAllDeclarationsAreFromTheSameType(final DecContent dec) {
    EList<VarContent> _nextCon = dec.getNextCon();
    boolean _isEmpty = _nextCon.isEmpty();
    if (_isEmpty) {
      return;
    }
    VarContent original = dec.getSingleContent();
    final String type = SQFValidator.getType(original);
    boolean _equals = Objects.equal(type, "undefined");
    if (_equals) {
      return;
    }
    EList<VarContent> _nextCon_1 = dec.getNextCon();
    int _length = ((Object[])Conversions.unwrapArray(_nextCon_1, Object.class)).length;
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _length, true);
    for (final Integer i : _doubleDotLessThan) {
      {
        EList<VarContent> _nextCon_2 = dec.getNextCon();
        final VarContent nextContent = _nextCon_2.get((i).intValue());
        final String nextType = SQFValidator.getType(nextContent);
        boolean _and = false;
        boolean _notEquals = (!Objects.equal(type, nextType));
        if (!_notEquals) {
          _and = false;
        } else {
          boolean _notEquals_1 = (!Objects.equal(nextType, "undefined"));
          _and = _notEquals_1;
        }
        if (_and) {
          final String errorMsg = ((("Mismatch in type " + nextType) + " -> expected ") + type);
          EReference _decContent_NextCon = SQFPackage.eINSTANCE.getDecContent_NextCon();
          this.error(errorMsg, _decContent_NextCon, (i).intValue(), SQFValidator.DECLARATIONS_ARE_SAME_TYPE);
        }
      }
    }
  }
  
  /**
   * Checks that arrays are not multiplied or divided (adding or substracting is allowed)
   */
  @Check
  public void checkArraysAreOnlyAddedOrSubstracted(final DecContent dec) {
    VarContent original = dec.getSingleContent();
    Declaration _parent = SQFValidator.getParent(original);
    String type = SQFValidator.getType(_parent);
    boolean _notEquals = (!Objects.equal(type, "array"));
    if (_notEquals) {
      return;
    }
    EList<String> _op = dec.getOp();
    boolean _isEmpty = _op.isEmpty();
    if (_isEmpty) {
      return;
    }
    EList<String> _op_1 = dec.getOp();
    int _length = ((Object[])Conversions.unwrapArray(_op_1, Object.class)).length;
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _length, true);
    for (final Integer i : _doubleDotLessThan) {
      {
        EList<String> _op_2 = dec.getOp();
        String operator = _op_2.get((i).intValue());
        boolean _and = false;
        boolean _notEquals_1 = (!Objects.equal(operator, "+"));
        if (!_notEquals_1) {
          _and = false;
        } else {
          boolean _notEquals_2 = (!Objects.equal(operator, "-"));
          _and = _notEquals_2;
        }
        if (_and) {
          String errorMsg = (("The operator \'" + operator) + "\' is undefined for type array");
          EAttribute _decContent_Op = SQFPackage.eINSTANCE.getDecContent_Op();
          this.error(errorMsg, _decContent_Op, (i).intValue(), SQFValidator.ARRAYS_ONLY_ADDED_OR_SUBSTRACTED);
        }
      }
    }
  }
  
  /**
   * Checks that strings can only make use of the + operator
   */
  @Check
  public void checkStringsOnlyUsePlusOperator(final DecContent dec) {
    EList<VarContent> _nextCon = dec.getNextCon();
    boolean _isEmpty = _nextCon.isEmpty();
    if (_isEmpty) {
      return;
    }
    VarContent _singleContent = dec.getSingleContent();
    Declaration _parent = SQFValidator.getParent(_singleContent);
    String type = SQFValidator.getType(_parent);
    boolean _notEquals = (!Objects.equal(type, "string"));
    if (_notEquals) {
      return;
    }
    EList<VarContent> _nextCon_1 = dec.getNextCon();
    int _length = ((Object[])Conversions.unwrapArray(_nextCon_1, Object.class)).length;
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _length, true);
    for (final Integer i : _doubleDotLessThan) {
      {
        EList<String> _op = dec.getOp();
        String operator = _op.get((i).intValue());
        boolean _notEquals_1 = (!Objects.equal(operator, "+"));
        if (_notEquals_1) {
          String errorMsg = (("The operator \'" + operator) + "\' is not defined for type string");
          EAttribute _decContent_Op = SQFPackage.eINSTANCE.getDecContent_Op();
          this.error(errorMsg, _decContent_Op, (i).intValue(), SQFValidator.STRINGS_ONLY_PLUS_OPERATOR);
        }
      }
    }
  }
  
  /**
   * Checks that all content within one bracket is from the same type
   */
  @Check
  public void checkAllDeclarationsAreFromTheSameTypeBrackets(final VarContent con) {
    BracketContent _embrCon = con.getEmbrCon();
    boolean _equals = Objects.equal(_embrCon, null);
    if (_equals) {
      return;
    }
    BracketContent _embrCon_1 = con.getEmbrCon();
    DecContent bracketContent = _embrCon_1.getDecCon();
    this.checkAllDeclarationsAreFromTheSameType(bracketContent);
  }
  
  /**
   * Checks that "select" is only used with arrays
   */
  @Check
  public void checkSelectIsUsedOnArraysOnly(final VarContent dec) {
    String _sel = dec.getSel();
    boolean _equals = Objects.equal(_sel, null);
    if (_equals) {
      return;
    }
    final Declaration declaration = dec.getReference();
    final String declarationType = SQFValidator.getType(declaration);
    boolean _notEquals = (!Objects.equal(declarationType, "array"));
    if (_notEquals) {
      final String errorMsg = ("The command \'select\' is not applicable for type " + declarationType);
      EAttribute _varContent_Sel = SQFPackage.eINSTANCE.getVarContent_Sel();
      this.error(errorMsg, _varContent_Sel, 
        SQFValidator.SELECT_ONLY_FOR_ARRAYS);
    }
  }
  
  /**
   * Checks that negation operators("!" and "not") are only applied to boolean expressions
   */
  @Check
  public void checkNegationOperatorOnlyUsedForBooleanExpressions(final DecContent dec) {
    String _neg = dec.getNeg();
    boolean _equals = Objects.equal(_neg, null);
    if (_equals) {
      return;
    }
    final String operator = dec.getNeg();
    final VarContent current = dec.getSingleContent();
    EObject _eContainer = dec.eContainer();
    final BracketContent brCon = ((BracketContent) _eContainer);
    final String type = SQFValidator.getType(brCon);
    boolean _notEquals = (!Objects.equal(type, "boolean"));
    if (_notEquals) {
      final String errorMsg = ((("The operator \'" + operator) + "\' is not defined for type ") + type);
      EAttribute _decContent_Neg = SQFPackage.eINSTANCE.getDecContent_Neg();
      this.error(errorMsg, _decContent_Neg, 
        SQFValidator.NEGATION_OPERATOR_ONLY_BOOLEAN);
      return;
    }
  }
  
  /**
   * Checks that a comparison is only done via "==" if 2 values of the same type is used
   */
  @Check
  public void checkComparisonDoneOnlyBetweenSameTypes(final BracketContent brCon) {
    boolean _or = false;
    EList<String> _comp = brCon.getComp();
    boolean _isEmpty = _comp.isEmpty();
    if (_isEmpty) {
      _or = true;
    } else {
      EList<DecContent> _content = brCon.getContent();
      boolean _isEmpty_1 = _content.isEmpty();
      _or = _isEmpty_1;
    }
    if (_or) {
      return;
    }
    EList<String> _comp_1 = brCon.getComp();
    int _length = ((Object[])Conversions.unwrapArray(_comp_1, Object.class)).length;
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _length, true);
    for (final Integer i : _doubleDotLessThan) {
      {
        EList<String> _comp_2 = brCon.getComp();
        String comparator = _comp_2.get((i).intValue());
        VarContent firstContent = null;
        if (((i).intValue() == 0)) {
          DecContent _decCon = brCon.getDecCon();
          VarContent _singleContent = _decCon.getSingleContent();
          firstContent = _singleContent;
        } else {
          EList<DecContent> _content_1 = brCon.getContent();
          DecContent _get = _content_1.get(((i).intValue() - 1));
          VarContent _singleContent_1 = _get.getSingleContent();
          firstContent = _singleContent_1;
        }
        EList<DecContent> _content_2 = brCon.getContent();
        DecContent _get_1 = _content_2.get((i).intValue());
        VarContent nextContent = _get_1.getSingleContent();
        String firstType = SQFValidator.getType(firstContent);
        String nextType = SQFValidator.getType(nextContent);
        boolean _and = false;
        boolean _and_1 = false;
        boolean _and_2 = false;
        boolean _equals = firstType.equals(nextType);
        boolean _not = (!_equals);
        if (!_not) {
          _and_2 = false;
        } else {
          boolean _notEquals = (!Objects.equal(firstType, "undefined"));
          _and_2 = _notEquals;
        }
        if (!_and_2) {
          _and_1 = false;
        } else {
          boolean _notEquals_1 = (!Objects.equal(nextType, "undefined"));
          _and_1 = _notEquals_1;
        }
        if (!_and_1) {
          _and = false;
        } else {
          boolean _notEquals_2 = (!Objects.equal(comparator, "isEqualTo"));
          _and = _notEquals_2;
        }
        if (_and) {
          final String errorMsg = (((((("Can\'t compare type " + firstType) + " and ") + nextType) + " with comparator \'") + comparator) + "\'");
          EAttribute _bracketContent_Comp = SQFPackage.eINSTANCE.getBracketContent_Comp();
          this.error(errorMsg, _bracketContent_Comp, (i).intValue(), SQFValidator.COMPARISON_ONLY_WITH_SAME_TYPE);
        }
      }
    }
  }
  
  /**
   * Checks that there is no cycle in hierarchy
   */
  @Check
  public void checkNoCycleInHierarchy(final Declaration dec) {
    VarContent _varContent = SQFValidator.varContent(dec);
    Declaration _reference = _varContent.getReference();
    boolean _equals = Objects.equal(_reference, null);
    if (_equals) {
      return;
    }
    String _name = dec.getName();
    VarContent _varContent_1 = SQFValidator.varContent(dec);
    Declaration _reference_1 = _varContent_1.getReference();
    String _name_1 = _reference_1.getName();
    boolean _equals_1 = Objects.equal(_name, _name_1);
    if (_equals_1) {
      return;
    }
    VarContent content = SQFValidator.varContent(dec);
    ArrayList<String> names = CollectionLiterals.<String>newArrayList();
    while (((!Objects.equal(content.getReference(), null)) && (!names.contains(SQFValidator.getParentName(content))))) {
      {
        String _parentName = SQFValidator.getParentName(content);
        names.add(_parentName);
        Declaration _reference_2 = content.getReference();
        VarContent _varContent_2 = SQFValidator.varContent(_reference_2);
        content = _varContent_2;
        String _parentName_1 = SQFValidator.getParentName(content);
        boolean _contains = names.contains(_parentName_1);
        if (_contains) {
          final String errorMsg = "Cycle in hierarchy!";
          EReference _declaration_BrCon = SQFPackage.eINSTANCE.getDeclaration_BrCon();
          this.error(errorMsg, _declaration_BrCon, 
            SQFValidator.CYCLE_IN_HIERARCHY);
          return;
        }
      }
    }
  }
  
  /**
   * Checks that the rule booleanContent contains only boolean
   */
  @Check
  public void checkBoolContentIsAlwaysBoolean(final BooleanContent bool) {
    BracketContent _boolCon = bool.getBoolCon();
    final String type = SQFValidator.getType(_boolCon);
    boolean _and = false;
    boolean _notEquals = (!Objects.equal(type, "boolean"));
    if (!_notEquals) {
      _and = false;
    } else {
      boolean _notEquals_1 = (!Objects.equal(type, "undefined"));
      _and = _notEquals_1;
    }
    if (_and) {
      final String errorMsg = (("Mismatch in type " + type) + " -> expected boolean");
      EReference _booleanContent_BoolCon = SQFPackage.eINSTANCE.getBooleanContent_BoolCon();
      this.error(errorMsg, _booleanContent_BoolCon, 
        SQFValidator.ONLY_BOOLEAN_ALLOWED);
    }
  }
  
  /**
   * Checks that a foreach only refers to an array
   */
  @Check
  public void checkForEachOnlyUsesArray(final ForeachType forEach) {
    Declaration _array = forEach.getArray();
    boolean _equals = Objects.equal(_array, null);
    if (_equals) {
      return;
    }
    Declaration _array_1 = forEach.getArray();
    final String type = SQFValidator.getType(_array_1);
    boolean _and = false;
    boolean _notEquals = (!Objects.equal(type, "array"));
    if (!_notEquals) {
      _and = false;
    } else {
      boolean _notEquals_1 = (!Objects.equal(type, "undefined"));
      _and = _notEquals_1;
    }
    if (_and) {
      final String errorMsg = "ForEach can only process arrays";
      EReference _foreachType_Array = SQFPackage.eINSTANCE.getForeachType_Array();
      this.error(errorMsg, _foreachType_Array, 
        SQFValidator.FOREACH_ONLY_ARRAY);
    }
  }
  
  /**
   * Tracks a reference back to it's delaration and returns the declaration content
   */
  public static DecContent getThatReference(final VarContent statement) {
    Declaration ref = statement.getReference();
    VarContent stat = statement;
    ArrayList<String> names = CollectionLiterals.<String>newArrayList();
    DecContent variable = SQFValidator.decCon(ref);
    while (((!Objects.equal(ref, null)) && (!names.contains(ref.getName())))) {
      {
        String _name = ref.getName();
        names.add(_name);
        DecContent _decCon = SQFValidator.decCon(ref);
        VarContent _singleContent = _decCon.getSingleContent();
        stat = _singleContent;
        DecContent _decCon_1 = SQFValidator.decCon(ref);
        variable = _decCon_1;
        Declaration _reference = stat.getReference();
        ref = _reference;
      }
    }
    return variable;
  }
  
  /**
   * finds out the type of the declaration and returns it ("number","string","array","undefined"; if nothing has matched:"Couldn'tResolveToType")
   */
  public static String getType(final VarContent con) {
    VarContent content = con;
    ArrayList<String> names = CollectionLiterals.<String>newArrayList();
    boolean proceed = true;
    while ((((!Objects.equal(content.getReference(), null)) || (!Objects.equal(content.getEmbrCon(), null))) && proceed)) {
      Declaration _reference = content.getReference();
      boolean _notEquals = (!Objects.equal(_reference, null));
      if (_notEquals) {
        final String name = SQFValidator.getReferenceName(content);
        boolean _contains = names.contains(name);
        if (_contains) {
          proceed = false;
        } else {
          names.add(name);
        }
        DecContent _thatReference = SQFValidator.getThatReference(content);
        VarContent _singleContent = _thatReference.getSingleContent();
        content = _singleContent;
      } else {
        BracketContent _embrCon = content.getEmbrCon();
        boolean _notEquals_1 = (!Objects.equal(_embrCon, null));
        if (_notEquals_1) {
          BracketContent _bracketContent = SQFValidator.getBracketContent(content);
          DecContent _decCon = ((BracketContent) _bracketContent).getDecCon();
          VarContent _singleContent_1 = _decCon.getSingleContent();
          content = _singleContent_1;
        } else {
          InputOutput.<String>println("ERROR: COULDN\'T RESOLVE REFERENCE/BRACKETS");
        }
      }
    }
    raven.sQF.Boolean _bool = content.getBool();
    boolean _notEquals = (!Objects.equal(_bool, null));
    if (_notEquals) {
      return "boolean";
    }
    String _num = content.getNum();
    boolean _notEquals_1 = (!Objects.equal(_num, null));
    if (_notEquals_1) {
      return "number";
    }
    String _string = content.getString();
    boolean _notEquals_2 = (!Objects.equal(_string, null));
    if (_notEquals_2) {
      return "string";
    }
    boolean _or = false;
    ArrayLiteral _arrayContent = content.getArrayContent();
    boolean _notEquals_3 = (!Objects.equal(_arrayContent, null));
    if (_notEquals_3) {
      _or = true;
    } else {
      boolean _and = false;
      String _param = content.getParam();
      boolean _notEquals_4 = (!Objects.equal(_param, null));
      if (!_notEquals_4) {
        _and = false;
      } else {
        String _index = content.getIndex();
        boolean _equals = Objects.equal(_index, null);
        _and = _equals;
      }
      _or = _and;
    }
    if (_or) {
      return "array";
    }
    boolean _and_1 = false;
    String _param_1 = content.getParam();
    boolean _notEquals_5 = (!Objects.equal(_param_1, null));
    if (!_notEquals_5) {
      _and_1 = false;
    } else {
      String _index_1 = content.getIndex();
      boolean _notEquals_6 = (!Objects.equal(_index_1, null));
      _and_1 = _notEquals_6;
    }
    if (_and_1) {
      return "undefined";
    }
    String _forEachVar = content.getForEachVar();
    boolean _notEquals_7 = (!Objects.equal(_forEachVar, null));
    if (_notEquals_7) {
      return "undefined";
    }
    return "Couldn\'tResolveToType";
  }
  
  public static String getType(final Declaration dec) {
    BracketContent _brCon = dec.getBrCon();
    final String type = SQFValidator.getType(_brCon);
    return type;
  }
  
  public static String getType(final BracketContent brCon) {
    BracketContent brContent = brCon;
    ArrayList<String> names = CollectionLiterals.<String>newArrayList();
    BracketContent boolChecker = null;
    boolean proceed = true;
    DecContent _decCon = brContent.getDecCon();
    VarContent content = _decCon.getSingleContent();
    EList<String> _comp = brContent.getComp();
    boolean _isEmpty = _comp.isEmpty();
    boolean isBool = (!_isEmpty);
    while ((((!Objects.equal(content.getReference(), null)) || (!Objects.equal(content.getEmbrCon(), null))) && proceed)) {
      Declaration _reference = content.getReference();
      boolean _notEquals = (!Objects.equal(_reference, null));
      if (_notEquals) {
        final String name = SQFValidator.getReferenceName(content);
        boolean _contains = names.contains(name);
        if (_contains) {
          proceed = false;
        } else {
          names.add(name);
        }
        if ((!isBool)) {
          EList<String> _comp_1 = brContent.getComp();
          boolean _isEmpty_1 = _comp_1.isEmpty();
          boolean _not = (!_isEmpty_1);
          isBool = _not;
          boolean _and = false;
          if (!(!isBool)) {
            _and = false;
          } else {
            boolean _notEquals_1 = (!Objects.equal(boolChecker, null));
            _and = _notEquals_1;
          }
          if (_and) {
            EList<String> _comp_2 = boolChecker.getComp();
            boolean _isEmpty_2 = _comp_2.isEmpty();
            boolean _not_1 = (!_isEmpty_2);
            isBool = _not_1;
          }
        }
        DecContent _thatReference = SQFValidator.getThatReference(content);
        VarContent _singleContent = _thatReference.getSingleContent();
        content = _singleContent;
        EObject _eContainer = content.eContainer();
        EObject _eContainer_1 = _eContainer.eContainer();
        brContent = ((BracketContent) _eContainer_1);
      } else {
        BracketContent _embrCon = content.getEmbrCon();
        boolean _notEquals_2 = (!Objects.equal(_embrCon, null));
        if (_notEquals_2) {
          BracketContent _bracketContent = SQFValidator.getBracketContent(content);
          brContent = ((BracketContent) _bracketContent);
          DecContent _decCon_1 = brContent.getDecCon();
          VarContent _singleContent_1 = _decCon_1.getSingleContent();
          content = _singleContent_1;
        } else {
          InputOutput.<String>println("ERROR: COULDN\'T RESOLVE REFERENCE/BRACKETS");
        }
      }
    }
    if ((!isBool)) {
      EList<String> _comp_1 = brContent.getComp();
      boolean _isEmpty_1 = _comp_1.isEmpty();
      boolean _not = (!_isEmpty_1);
      isBool = _not;
      boolean _and = false;
      if (!(!isBool)) {
        _and = false;
      } else {
        boolean _notEquals = (!Objects.equal(boolChecker, null));
        _and = _notEquals;
      }
      if (_and) {
        EList<String> _comp_2 = boolChecker.getComp();
        boolean _isEmpty_2 = _comp_2.isEmpty();
        boolean _not_1 = (!_isEmpty_2);
        isBool = _not_1;
      }
    }
    boolean _or = false;
    if (isBool) {
      _or = true;
    } else {
      raven.sQF.Boolean _bool = content.getBool();
      boolean _notEquals_1 = (!Objects.equal(_bool, null));
      _or = _notEquals_1;
    }
    if (_or) {
      return "boolean";
    }
    String _num = content.getNum();
    boolean _notEquals_2 = (!Objects.equal(_num, null));
    if (_notEquals_2) {
      return "number";
    }
    String _string = content.getString();
    boolean _notEquals_3 = (!Objects.equal(_string, null));
    if (_notEquals_3) {
      return "string";
    }
    String _execute = content.getExecute();
    boolean _notEquals_4 = (!Objects.equal(_execute, null));
    if (_notEquals_4) {
      return "methodCall";
    }
    boolean _or_1 = false;
    ArrayLiteral _arrayContent = content.getArrayContent();
    boolean _notEquals_5 = (!Objects.equal(_arrayContent, null));
    if (_notEquals_5) {
      _or_1 = true;
    } else {
      boolean _and_1 = false;
      String _param = content.getParam();
      boolean _notEquals_6 = (!Objects.equal(_param, null));
      if (!_notEquals_6) {
        _and_1 = false;
      } else {
        String _index = content.getIndex();
        boolean _equals = Objects.equal(_index, null);
        _and_1 = _equals;
      }
      _or_1 = _and_1;
    }
    if (_or_1) {
      return "array";
    }
    boolean _and_2 = false;
    String _param_1 = content.getParam();
    boolean _notEquals_7 = (!Objects.equal(_param_1, null));
    if (!_notEquals_7) {
      _and_2 = false;
    } else {
      String _index_1 = content.getIndex();
      boolean _notEquals_8 = (!Objects.equal(_index_1, null));
      _and_2 = _notEquals_8;
    }
    if (_and_2) {
      return "undefined";
    }
    String _forEachVar = content.getForEachVar();
    boolean _notEquals_9 = (!Objects.equal(_forEachVar, null));
    if (_notEquals_9) {
      return "undefined";
    }
    return "Couldn\'tResolveToType";
  }
  
  /**
   * gets the declaration content between brackets and returns it
   */
  public static BracketContent getBracketContent(final VarContent con) {
    BracketContent _embrCon = con.getEmbrCon();
    boolean _equals = Objects.equal(_embrCon, null);
    if (_equals) {
      EObject _eContainer = con.eContainer();
      EObject _eContainer_1 = _eContainer.eContainer();
      return ((BracketContent) _eContainer_1);
    }
    BracketContent content = con.getEmbrCon();
    return content;
  }
  
  /**
   * finds out the name of the declaration the Content belongs to
   */
  public static String getParentName(final VarContent con) {
    final Declaration parent = SQFValidator.getParent(con);
    final String name = parent.getName();
    return name;
  }
  
  /**
   * returns the parent Rule
   */
  public static Declaration getParent(final VarContent con) {
    Declaration _reference = con.getReference();
    final Declaration dummy = ((Declaration) _reference);
    EObject _eContainer = con.eContainer();
    EObject parentSuper = _eContainer.eContainer();
    Declaration parent = null;
    while (((!Objects.equal(parentSuper, null)) && (!(parentSuper instanceof Declaration)))) {
      EObject _eContainer_1 = parentSuper.eContainer();
      parentSuper = _eContainer_1;
    }
    boolean _equals = Objects.equal(parentSuper, null);
    if (_equals) {
      String _string = con.toString();
      String _plus = ("ERROR: Couldn\'t find parent to element " + _string);
      InputOutput.<String>println(_plus);
      return null;
    }
    if ((parentSuper instanceof Declaration)) {
      parent = ((Declaration) parentSuper);
    }
    return parent;
  }
  
  /**
   * Gets the name of the reference Declaration
   */
  public static String getReferenceName(final VarContent con) {
    Declaration _reference = con.getReference();
    boolean _equals = Objects.equal(_reference, null);
    if (_equals) {
      return null;
    }
    Declaration _reference_1 = con.getReference();
    final String name = ((Declaration) _reference_1).getName();
    return name;
  }
}
