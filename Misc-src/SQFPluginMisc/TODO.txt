fix problems with FixError

try-catch fest implementieren

Online wieder kontrollieren was net passt

Eine Anything-Regel generieren -> auf Linksrekursion achten

Deklarationsreferenzen implementieren

check ParserRule.createAssignments()

Grammar.sort() has to process subAtomic rules

null-ruleContents





	/**
	 * Check if the given ruleContent has a part starting with a ruleCall for
	 * another rule specified in ruleNames
	 * 
	 * @param ruleContent
	 *            The content of the rule to check
	 * @param ruleNames
	 *            ruleNames The rule names to search for
	 * @return
	 */
	public static boolean containsStartingRuleCallOf(String ruleContent,
			ArrayList<String> ruleNames) {

		String firstElement = Grammar.getFirstElement(ruleContent);
		if (firstElement.endsWith("|")) {
			firstElement = firstElement.substring(0, firstElement.length() - 1);
		}
		firstElement = ParserRule.cleanString(firstElement);

		if (ruleNames.contains(firstElement)) {
			return true;
		} else {
			// if first Element is surrounded by brackets thencheck the bracket
			// content
			if (firstElement.contains("(") || firstElement.contains(")")) {
				// remove brackets and special characters
				firstElement = firstElement.replace("(", " ");
				firstElement = firstElement.replace(")", " ");
				firstElement = firstElement.replace("*", " ");
				firstElement = firstElement.replace("?", " ");
				firstElement = firstElement.replace("|", " ");
				firstElement = cleanString(firstElement);
				firstElement = Functions.reduceSpaceBetween(firstElement);

				String[] elements = Functions.getElements(firstElement);

				for (String currentFirstElement : elements) {
					if (ruleNames.contains(currentFirstElement)) {
						return true;
					}
				}
			}
		}

		while (ruleContent.contains("\t|")) {
			ruleContent = ruleContent.substring(ruleContent.indexOf("\t|") + 2);
			ruleContent = cleanString(ruleContent);
			firstElement = Grammar.getFirstElement(ruleContent);
			if (firstElement.endsWith("|")) {
				firstElement = firstElement.substring(0,
						firstElement.length() - 1);
			}
			firstElement = cleanString(firstElement);

			if (ruleNames.contains(firstElement)) {
				return true;
			} else {
				// if first Element is surrounded by brackets thencheck the
				// bracket content
				if (firstElement.contains("(") || firstElement.contains(")")) {
					// remove brackets and special characters
					firstElement = firstElement.replace("(", " ");
					firstElement = firstElement.replace(")", " ");
					firstElement = firstElement.replace("*", " ");
					firstElement = firstElement.replace("?", " ");
					firstElement = firstElement.replace("|", " ");
					firstElement = cleanString(firstElement);
					firstElement = Functions.reduceSpaceBetween(firstElement);

					String[] elements = Functions.getElements(firstElement);

					for (String currentFirstElement : elements) {
						if (ruleNames.contains(currentFirstElement)) {
							return true;
						}
					}
				}
			}
		}

		// if previous didn't match then there is no such an starting ruleCall
		return false;
	}

	/**
	 * Check if the given rule has a part starting with a ruleCall for another
	 * rule specified in ruleNames
	 * 
	 * @param ruleNames
	 *            The rule names to search for
	 * @return
	 */
	public boolean containsStartingRuleCallOf(ArrayList<String> ruleNames) {
		boolean contains = false;
		contains = containsStartingRuleCallOf(this.getBaseRuleContent(),
				ruleNames);

		if (!contains) {
			contains = containsStartingRuleCallOf(this.getAtomicRuleContent(),
					ruleNames);
		}

		return contains;
	}

	/**
	 * Check if the given rule has a part starting with a ruleCall for the rule
	 * with the given name
	 * 
	 * @param name
	 *            The rule's name to search for
	 * @return
	 */
	public boolean containsStartingRuleCallOf(String name) {
		ArrayList<String> namesList = new ArrayList<String>();
		namesList.add(name);

		return containsStartingRuleCallOf(namesList);
	}

	/**
	 * Check if the given rule has a part starting with a ruleCall for the rule
	 * with the given name
	 * 
	 * @param ruleContent
	 *            The content of the rule to be checked
	 * @param name
	 *            The name of the ruleCall to search for
	 * @return
	 */
	public static boolean containsStartingRuleCallOf(String ruleContent,
			String name) {
		ArrayList<String> nameList = new ArrayList<String>();
		nameList.add(name);

		return containsStartingRuleCallOf(ruleContent, nameList);
	}